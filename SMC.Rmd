---
title: "SMC"
author: "Ant Stephenson, Shannon Williams"
date: "5/25/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

## Sequential Monte Carlo


## Stochastic Volatility Models



We define a function to generate data according to the SV model:
```{r, cache=TRUE, code=xfun::read_utf8('R/generateSVmodel.R'), gensv}
```

To model the latent variables in the SV model we implement a bootstrap particle filter in `R`:

```{r, cache=TRUE, code=xfun::read_utf8('R/Bootstrap_SV.R'), bootR}
```

and additionally in `C++` making use of the `Rcpp` package in order to make simulations more computationally manageable. We go on to test that a) the results match (excluding variations due to unset random seeds in C++) and b) that the C++ implementation is indeed faster than in `R`.

```{cc, cache=TRUE, code=xfun::read_utf8('src/particles.cpp'), particles}
```

```{r, test}
detach("package:smc", unload=TRUE)
rm(list = ls())
library(smc)
library(Rcpp)

set.seed(1)

tmax <- 500
mu <- -1
rho <- 0.95
sigma <- 0.15

Xt <- generate_SV_data(mu, rho, sigma, tmax)
Yt <- as.matrix(rnorm(tmax, mean = 0, sd = sqrt(exp(Xt))))
boot_sv <- Bootstrap_SV$new(data = Yt, mu = -1, sigma = 0.15, rho = 0.95)

N <- 5000
output <- bootstrap_filter(boot_sv, N, tmax)

mod <- Module("particles", PACKAGE="smc")
Bootstrap_SV_C <- mod$Bootstrap_SV_C
boot_sv_rcpp <- new(Bootstrap_SV_C, Yt, -1, 0.15, 0.95)
output2 <- mod$bootstrap_filter_rcpp(boot_sv_rcpp, N ,tmax)

par(mfrow = c(1,2))
plot(Xt, type = "l")
lines(output$mx, col = "red")
lines(output2$mx, col="green")
plot(1:tmax, output$ess, type = "l")

rm(output)
rm(output2)
gc()

library(microbenchmark)

run_filter <- function(filter_fn, ...) {
  out <- filter_fn(...)
  rm(out)
  gc()
  return(NA)
}
funcs <- c(call("run_filter", bootstrap_filter, boot_sv, N, tmax), call("run_filter", mod$bootstrap_filter_rcpp, boot_sv_rcpp, N, tmax))

bench_res <- microbenchmark(list=setNames(funcs, c("R","Rcpp")),
               times=5L)

print(bench_res, signif=3)
```

## SMC^2

The particle filter implementation above relies on knowing the parameters $\theta, \rho, \mu$ *a priori*. Of course, this is not likely in any realistic scenario, so we must be able to estimate these parameters as well. Here we choose to implement the SMC^2 algorithm to simultaneously estimate the parameters alongside state estimation with the particle filter.

